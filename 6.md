Шестая группа вопросов посвящена **языку SQL (Structured Query Language)**, а именно его базовым возможностям и операциям выборки данных (**DQL** — Data Query Language). Это фундамент практической работы с любыми реляционными БД.

---

### 1. Функции и основные возможности языка SQL. Отличия от процедурных языков

**SQL** — это декларативный язык структурированных запросов, ставший стандартом для работы с реляционными БД.

**Основные функции (подмножества языка):**
1.  **DDL (Data Definition Language):** Создание и изменение структуры (таблиц, индексов).
2.  **DML (Data Manipulation Language):** Работа с данными (вставка, удаление, обновление).
3.  **DQL (Data Query Language):** Извлечение (выборка) данных.
4.  **DCL (Data Control Language):** Управление правами доступа.
5.  **TCL (Transaction Control Language):** Управление транзакциями.

**Отличия от процедурных языков (C++, Java, Python):**
*   **Декларативность:** В процедурных языках программист пишет *алгоритм* (как получить результат). В SQL программист описывает *результат* (что нужно получить), а СУБД сама решает, как это сделать (выбирает план запроса).
*   **Направленность на множества:** SQL оперирует сразу наборами строк (множествами), а не отдельными переменными или объектами в цикле.
*   **Отсутствие управляющих структур:** В стандартном SQL нет циклов и ветвлений (они появляются только в расширениях типа T-SQL или PL/SQL).

---

### 2. Типы данных SQL

Основные категории типов данных в стандарте SQL:
*   **Числовые:** `INTEGER` (целые), `DECIMAL`/`NUMERIC` (точные дробные для финансов), `FLOAT`/`REAL` (числа с плавающей точкой).
*   **Строковые:** `CHAR(n)` (фиксированная длина), `VARCHAR(n)` (переменная длина), `TEXT` (большие объемы текста).
*   **Дата и время:** `DATE` (только дата), `TIME` (только время), `TIMESTAMP` / `DATETIME` (дата и время).
*   **Логические:** `BOOLEAN` (TRUE, FALSE, UNKNOWN).
*   **Двоичные:** `BLOB` (Binary Large Object) для картинок, файлов.

---

### 3. Синтаксис простейших SELECT-запросов

Базовая структура запроса:
```sql
SELECT [DISTINCT] список_столбцов | *
FROM имя_таблицы
[WHERE условие_фильтрации]
[ORDER BY столбец [ASC | DESC]];
```
*   `SELECT *`: Выбрать все столбцы.
*   `DISTINCT`: Исключить дубликаты строк в результате.
*   `WHERE`: Ограничивает выборку строк по условию.
*   `ORDER BY`: Сортировка (ASC — по возрастанию (дефолт), DESC — по убыванию).

---

### 4. Разъясните работу операторов IN, BETWEEN, LIKE, IS NULL

Эти операторы используются в секции `WHERE`:
*   **IN (список_значений):** Проверяет, совпадает ли значение поля с любым из списка.
    *   *Пример:* `WHERE city IN ('Москва', 'Киев', 'Минск')`.
*   **BETWEEN начало AND конец:** Проверяет вхождение в диапазон (включая границы).
    *   *Пример:* `WHERE price BETWEEN 100 AND 500`.
*   **LIKE 'шаблон':** Поиск по маске.
    *   `%` — любая последовательность символов (включая пустую).
    *   `_` — ровно один любой символ.
    *   *Пример:* `WHERE name LIKE 'А%'` (начинается на А).
*   **IS NULL:** Проверяет наличие пустого значения (отсутствие данных).
    *   *Пример:* `WHERE phone IS NULL`.

---

### 5. Групповые функции и примеры работы

Групповые (агрегатные) функции выполняют вычисления над набором строк и возвращают одно значение.
*   **COUNT():** Количество строк.
*   **SUM():** Сумма значений.
*   **AVG():** Среднее арифметическое.
*   **MIN() / MAX():** Минимальное и максимальное значения.

*Пример с группировкой:*
```sql
SELECT department_id, AVG(salary), COUNT(*)
FROM employees
GROUP BY department_id
HAVING AVG(salary) > 50000;
```
*(Сначала группируем по ID отдела, считаем среднюю зарплату, а `HAVING` отсеивает группы, где средняя зарплата меньше 50к).*

---

### 6. Вложенные подзапросы с использованием оператора EXISTS

**EXISTS** — это логический оператор, который проверяет, возвращает ли подзапрос хотя бы одну строку. Он возвращает TRUE или FALSE.
*   СУБД прекращает выполнение подзапроса, как только найдена первая подходящая строка (это эффективно).

*Пример:* Найти всех клиентов, у которых есть хотя бы один заказ:
```sql
SELECT name FROM customers c
WHERE EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.id);
```

---

### 7. Принцип формирования связанных (коррелированных) подзапросов

**Связанный подзапрос** — это подзапрос, который ссылается на колонку из внешнего запроса.
*   **Принцип работы:** Подзапрос выполняется **для каждой строки** внешнего запроса.
*   Внешний запрос передает значение в подзапрос, подзапрос возвращает результат, внешний запрос использует его для принятия решения.
*   Такие запросы обычно работают медленнее обычных, так как вызывают многократное перевыполнение внутреннего кода.

---

### 8. Условия работы оператора объединения UNION

Оператор **UNION** объединяет результаты двух и более запросов в один набор данных.
**Условия:**
1.  Количество столбцов в каждом `SELECT` должно быть одинаковым.
2.  Типы данных соответствующих столбцов должны быть совместимы.
3.  По умолчанию `UNION` удаляет дубликаты. Чтобы сохранить все строки, используется `UNION ALL` (работает быстрее).

---

### 9. Работа различных видов оператора JOIN

Соединения позволяют объединять данные из нескольких таблиц на основе общего поля (обычно PK и FK).

1.  **INNER JOIN (Внутреннее):** Возвращает только те строки, для которых нашлось совпадение в обеих таблицах.
2.  **LEFT (OUTER) JOIN (Левое внешнее):** Возвращает **все** строки из левой таблицы и подходящие из правой. Если в правой таблице совпадений нет, подставляются `NULL`.
3.  **RIGHT (OUTER) JOIN (Правое внешнее):** Возвращает все строки из правой таблицы и подходящие из левой.
4.  **FULL (OUTER) JOIN:** Возвращает все строки из обеих таблиц, заполняя `NULL` там, где нет пары.
5.  **CROSS JOIN:** Декартово произведение — каждая строка первой таблицы соединяется с каждой строкой второй (результат $N \times M$ строк).

*Пример (INNER JOIN):*
```sql
SELECT users.name, orders.date
FROM users
JOIN orders ON users.id = orders.user_id;
```
