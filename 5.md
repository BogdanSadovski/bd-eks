Пятая группа вопросов посвящена **внутренним механизмам СУБД**, которые обеспечивают надежность, сохранность данных и возможность одновременной работы множества пользователей. Это критически важная тема для понимания того, как база данных выживает при сбоях и как она управляет конфликтами доступа.

---

### 1. Понятие ссылочной целостности баз данных и механизмы её поддержания

**Ссылочная целостность (Referential Integrity)** — это состояние базы данных, при котором все значения внешних ключей (Foreign Keys) в дочерних таблицах соответствуют существующим значениям первичных ключей (Primary Keys) в родительских таблицах. Это исключает появление «записей-сирот».

**Механизмы поддержания:**
При попытке удалить или изменить строку в родительской таблице, на которую ссылаются другие таблицы, СУБД может применить следующие стратегии:
1.  **RESTRICT (Ограничение):** Запрещает удаление/изменение родительской записи, если на неё есть ссылки.
2.  **NO ACTION:** Аналогично RESTRICT, но проверка происходит в самом конце транзакции.
3.  **CASCADE (Каскадирование):** При удалении родительской записи автоматически удаляются все связанные записи в дочерних таблицах. При обновлении ключа — обновляются и ссылки.
4.  **SET NULL:** При удалении родительской записи значения внешнего ключа в дочерних строках устанавливаются в NULL (если поле это позволяет).
5.  **SET DEFAULT:** Устанавливает внешнему ключу значение по умолчанию.

---

### 2. Понятие транзакции и целостность баз данных

**Транзакция** — это неделимая, логически завершенная единица работы с данными (набор из одного или нескольких SQL-запросов).

Для обеспечения целостности транзакция должна обладать свойствами **ACID**:
*   **A (Atomicity) — Атомарность:** Транзакция выполняется полностью или не выполняется вовсе («всё или ничего»).
*   **C (Consistency) — Согласованность:** По завершении транзакции данные должны удовлетворять всем правилам (ограничениям) системы.
*   **I (Isolation) — Изолированность:** Параллельные транзакции не должны влиять друг на друга.
*   **D (Durability) — Долговечность:** Если транзакция зафиксирована (COMMIT), её результаты не должны быть потеряны даже при системном сбое.

---

### 3. Уровни изолированности транзакций

Изолированность позволяет избежать аномалий (грязное чтение, неповторяющееся чтение, фантомы). Выделяют 4 стандартных уровня (по стандарту SQL-92):

1.  **Read Uncommitted (Чтение незафиксированных данных):** Самый низкий уровень. Разрешено «грязное чтение» — транзакция видит изменения, внесенные другой незавершенной транзакцией.
2.  **Read Committed (Чтение зафиксированных данных):** Транзакция видит только закоммиченные данные. Защищает от грязного чтения. Самый частый уровень по умолчанию.
3.  **Repeatable Read (Повторяющееся чтение):** Гарантирует, что при повторном чтении данных внутри одной транзакции результат будет прежним. Защищает от «неповторяющегося чтения», но возможны «фантомы» (появление новых строк).
4.  **Serializable (Сериализуемость):** Самый высокий уровень. Транзакции выполняются так, будто они идут строго по очереди. Полная защита от всех аномалий.

---

### 4. Структура внешней памяти базы данных

СУБД хранит данные на диске не в виде сплошного потока, а структурировано для скорости доступа:
1.  **Блоки (или Страницы):** Минимальная единица обмена данными между диском и оперативной памятью (обычно 4 КБ или 8 КБ). Страница содержит заголовки и сами строки (кортежи).
2.  **Экстенты:** Группы из нескольких (обычно 8) последовательных страниц. Используются для выделения места таблицам.
3.  **Файлы данных:** Физические файлы в ОС, где размещаются страницы и экстенты.
4.  **Табличные пространства (Tablespaces):** Логическая группировка файлов данных.
5.  **Файлы журналов:** Отдельные файлы для фиксации изменений (Redo logs).

---

### 5. Понятие журнализации изменений

**Журнализация** — это процесс записи всех изменений БД в специальный файл (журнал транзакций) до того, как они будут фактически записаны в файлы данных.

**Принцип WAL (Write-Ahead Logging):**
Сначала запись об изменении должна попасть на диск в журнал, и только потом данные в памяти могут быть помечены как «грязные» для последующей записи на диск.
*   **Redo-логи:** Нужны для повтора операций при восстановлении после сбоя.
*   **Undo-логи:** Нужны для отката транзакций, которые не были завершены успешно.

---

### 6. Назначение и методы сериализации транзакций

**Назначение:** Организовать выполнение параллельных транзакций таким образом, чтобы итоговый результат был эквивалентен какому-либо их последовательному выполнению. Это гарантирует отсутствие логических ошибок в данных.

**Методы сериализации:**
1.  **Блокировки (Locking):** Запрет доступа к данным, пока их использует другая транзакция.
2.  **Метод временных меток (Timestamping):** Каждой транзакции дается уникальный номер времени.
3.  **Оптимистические методы:** Проверка конфликтов происходит только в момент фиксации (COMMIT). Если конфликт был — откат.
4.  **Многоверсионность (MVCC):** Чтение происходит из «снимка» данных, актуального на момент начала транзакции.

---

### 7. Назначение синхронизационных захватов и причины тупиков

**Синхронизационные захваты (Блокировки)** — это механизм управления доступом. Бывают:
*   **S-замок (Shared):** Разделяемая блокировка для чтения. Много транзакций могут читать одновременно.
*   **X-замок (Exclusive):** Исключительная блокировка для записи. Пока она держится, никто другой не может ни читать, ни писать.

**Причины тупиков (Deadlocks):**
Тупик возникает, когда две или более транзакции образуют циклическую зависимость:
*   Транзакция А держит ресурс 1 и ждет ресурс 2.
*   Транзакция Б держит ресурс 2 и ждет ресурс 1.
СУБД обнаруживает тупик (через граф ожиданий) и принудительно прерывает одну из транзакций (жертву), чтобы дать остальным продолжить работу.

---

### 8. Суть метода временных меток

Метод временных меток — это альтернатива блокировкам. Каждой транзакции $T$ присваивается метка $TS(T)$ (время старта). Для каждого объекта данных хранятся две метки:
*   $R(x)$ — время последнего чтения объекта.
*   $W(x)$ — время последней записи объекта.

**Суть правил:**
*   Если транзакция пытается **прочитать** объект, который уже был **изменен** более «молодой» транзакцией ($TS(T) < W(x)$), то транзакция $T$ откатывается.
*   Если транзакция пытается **записать** объект, который уже был **прочитан** или **изменен** более «молодой» транзакцией ($TS(T) < R(x)$ или $TS(T) < W(x)$), она также откатывается.

**Плюс метода:** Отсутствие тупиков.
**Минус:** При высокой нагрузке возможны частые откаты транзакций (проблема «голодания»).
